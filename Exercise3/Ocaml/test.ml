(* test MyList.nth *)
let () = assert (MyList.nth [ 1; 2; 3 ] 0 = Some 1)
let () = assert (MyList.nth [ 1; 2; 3 ] 1 = Some 2)
let () = assert (MyList.nth [ 1; 2; 3 ] 2 = Some 3)

(* exception when oor *)
let () = assert (try let _ = MyList.nth [1; 2; 3] 3 in false with Failure _ -> true)

(* test MyList.at *)
let () = assert (MyList.at 0 [ 1; 2; 3 ] = Some 1)
let () = assert (MyList.at 1 [ 1; 2; 3 ] = Some 2)
let () = assert (MyList.at 2 [ 1; 2; 3 ] = Some 3)
let () = assert (try let _ = MyList.at 3 [1; 2; 3] in false with Failure _ -> true)
(* How does the last line above read? *)
(* It reads: try to get the 3rd element of the list [1; 2; 3], and if it fails, return true *)
(* And what does the "in false" part mean? *)
(* It means that the expression "let _ = MyList.at 3 [1; 2; 3] in false" evaluates to false *)
(* Why do we need the "in false" part? *)
(* Because the try-with expression needs to evaluate to a boolean value *)
(* This is because the assert function takes a boolean value as an argument *)
(* So we need to make sure that the try-with expression evaluates to a boolean value *)
(* And the "in false" part makes sure that the try-with expression evaluates to a boolean value *)
(* However, since the try-with expression will always fail, the "in false" part will never be evaluated *)
(* So the "in false" part is just a dummy expression that will never be evaluated *)
(* And the try-with expression will always fail, so the assert function will always pass *)
let () = Printf.printf "MyList.nth: OK\n"
let () = Printf.printf "MyList.at: OK\n"
